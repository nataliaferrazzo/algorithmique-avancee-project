Compte Rendu projet Algorithimique avancee:

Introduction:
We chose to develop our project by programming with C language because it's one of the two languages (with ocaml) that we already used for previous project which needed to create our own structures.
Futhermore the use of pointers fits very well with the need to rely each node or tree to their children. The first issue we thought about after choosing this language is that we will have to handle the memory directly in the code which can add some difficulties.   
The version of the compiler i am using is : gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)

Question 1.1:
Our first idea to get the end of a word was to take the first element of the ascii table which is null. But actually after trying to convert the text to a new format with the separation with space we saw that the good element to take was '\n'.

Question 3.7:
To merge two Patricia trees the main steps are:
    1- Count the number of words in one of the tree
    2- Create a list of char* of this size 
    3- Put all the words of one tree in a list
    4- Insert one by one the words of the list in the other Patricia tree.

There is maybe a better way to do it by comparing directly the prefixes but the implementations would be harder, as we already the fonctions to do the described method.

Question 4.9 :
For each fonction the complexity will be based on the number of comparaison done in the fonction.
To check if the label matches the start of the word in the worst case we need to check over all the letter of the alphabet. And so for all the following fonctions if the complexity founded is smaller than this one (for a specific input),
we would have to take the alphabet size.

    SearchPatricia(tree, word): complexity of searchPatricia function is O(n), where n is the length of the input word.
This accounts for the compact representation of prefixes which allows us, after only one comparaison in the previous children, to find the one where there is a common prefixe.

    countWords(root):
This fonction just has to go throught every nodes and for each one check if isEndOfWord is true.
So the complexity is the number of nodes.

    hauteur(tree):
complexity for this fonction is the number of node in the tree as we have to go throught each one to find which branch is the biggest.

    ListeMots(tree):
collectWords is called over all nodes in the tree, so already n comparaisons. and as it calls sortChildren every time we have also n*O(sortChildren) which depends of the number of children of the node.
So the complexity in the worst case for this fonction is O(n*k) where k is the mean number of children for each node.
If we didn't care about the alphabetic order, ListeMots would be O(n).

    ComptageNil(tree):
complexity for this fonction is the number of node in the tree as we have to go throught each one to look for their pointers to null.

    ProfondeurMoyenne(tree):
complexity for this fonction is also the number of node in the tree as we have to go throught each one to add their depht. We then just have to do a division by the number of leafs.

    Prefixe(tree, word):
In the worst case there are lot of words with the same prefixe and they might also have some other prefixe in common, and they are far in the list of children.
So would be the max between : 
    alphabet size * length of prefixe wanted 
    the number of nodes in the subtree from the common prefixe

    Suppression(tree, word):
I don't know yet but it's at least the same as searchPatricia because we have to find the word. And then maybe to handle there is a comparaison to know if we have to delete the node or not.
but deleting the node is probaly not important when calling this fonction on a big tree . 

















